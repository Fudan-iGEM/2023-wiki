---
sidebar: auto
title: Software
author:
- Zhiyue Chen
authorlink:
- /fudan/team/#zhiyue-chen-the-software-wizard
---

::: tip
Live demo of RAP is available. Visit our live demo [here](http://54.169.242.254:5000/)!
:::

## Overview

Improving chassis metabolism is crucial for applications in synthetic biology. And the design of synthetic biology applications often involves multiple enzymes working together to form a cascade reaction. Flux imbalance frequently occur in unoptimized cascade events, which may lead to things like the appearance of the speed limit step, the occurrence of metabolic stress on cells, and the accumulation of cytotoxic intermediates. The success of the Ribozyme-Assisted Polycistronic co-expression system (pRAP system) and the benefits of replacing multiple promoter co-expression system in improving chassis metabolism have been demonstrated by [Fudan iGEM 2022](https://2022.igem.wiki/fudan/parts#composite). However, the Fudan iGEM 2022 has two shortcomings for the use of the pRAP system:

1. Lack of quantitative regulation for the pRAP system. Fudan iGEM 2022 regulates the expression of different proteins in pRAP by qualitatively changing the intensity of ribosome binding site (RBS).
2. Only one regulatory element in the pRAP system has been used. Fudan iGEM 2022 only attempted to replace the RBS and did not involve the regulation of the stem loop. In the pRAP system, both the RBS and the stem loop can regulate protein expression.

This year, we developed a pRAP system design software that can support the entire Design-Build-Test-Learn cycle (DBTL cycle): RAP. RAP consists of three parts: [KineticHub](#kinetichub), [RAP Builder](#rap-builder) and [PartHub 2](#parthub-2). The functions of RAP incorporate parts searching, calculation of optimal concentrations of enzymes, and pRAP system sequence construction. RAP has made a number of efforts to improve the user experience. To make RAP more user-friendly, we have designed an intuitive web-based interactive interface with tutorials, and for advanced usage of RAP, we have provided a series of RESTFul APIs, and for better use of sequences generated by RAP, we have adopted the GeneBank format to save sequences, which is an existing synthetic biology standards, and the sequences can be used in external tools such as SnapGene. In order to get feedback from users other than the Fudan iGEM 2023 team members to increase user-friendliness, we have collaborated with other iGEM teams and improved RAP. Meanwhile, RAP is validated by a series of experimental results.

RAP has gone through several DBTL cycles (see 链接), leading to a concise workflow for RAP (Figure 1).

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-workflow.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 1: Workflow of RAP</small></p>
    </div>
</div>

### Highlights

- Intuitive WebUI with APIs for advanced development
- Compatible with and leveraging GeneBank format and easy integration with SnapGene
- Support throughout the DBTL cycle
- Experimentally validated results
- Comprehensive documentation and tutorials

In summary, RAP has led to a revolution in gene circuit design, offering new perspectives as well as strategies for handling the flux optimization. The software is freely available at our [team’s GitLab repository](https://gitlab.igem.org/2023/software-tools/fudan).

## pRAP system

Before getting started with RAP, it's essential to comprehend what a pRAP system is and how it works. It is indicated that the major problem of polycistronic vectors, which contain two or more target genes under one promoter, is the much lower expression of the downstream genes compared with that of the first gene next to the promoter[^1]. So we need to employ pRAP instead of assembling CDSs sequentially. In pRAP (Figure 2), the RNA sequences of hammerhead ribozyme conduct self-cleaving, and the polycistronic mRNA transcript is thus co-transcriptionally converted into individual mono-cistrons *in vivo*[^2] .

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/prap-czy.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 2: Structure of pRAP system</small></p>
    </div>
</div>

Compraed with multiple promoter system, self-interaction of the polycistron can be avoid and each cistron can initiate translation with comparable efficiency. In the pRAP system, there are two regulatory elements: the RBS and the stem loop. By regulating the intensity of these two regulatory elements, we can control the expression of proteins. RBS intensity influences the rate of translation initiation by influencing ribosome binding to mRNA, which in turn impacts protein concentration. Stem loop affects protein concentration by regulating the rate of mRNA degradation[^3]. For more details on building pRAP system, please refer to [RAP Builder](#rap-builder).

In addition, the pRAP system has two other advantages:

1. No CDS changes are required to build the pRAP system. Since the regulatory elements are not in the CDS, designing a pRAP system only requires adding regulatory elements upstream and downstream of the CDS, which is "painless" for most project requirements.
2. Compared to the multi-promoter strategy, polycistronic expression provides reproducible ratios of the synthesized proteins, mitigating the effect on protein expression of the fluctuating transcription associated with multiple promoters [^4].

For more details about pRAP system, please visit here介绍pRAP.

## Web UI

User interface improvements were mentioned in several Learn phases of the DBTL cycles for RAP development, so we developed an intuitive but powerful Web UI for RAP. RAP's Web UI is based on vue, using Ant Design Vue as the front-end component library and Axios to access and process the APIs. Neovis.js was used to visualize the network structure in PartHub 2.

Web UI of RAP has good compatibility and support the following browsers (Table 1).

<div style="text-align: center;">
    <p>Table 1: Browsers support of the Web UI (until Oct 2023).</p>
</div>


| <img src='https://static.igem.wiki/teams/4765/wiki/czy/edge-logo-czy.svg' style='height:2rem'>IE / Edge | <img src='https://static.igem.wiki/teams/4765/wiki/czy/firefox-logo-czy.svg' style='height:2rem'>Firefox | <img src='https://static.igem.wiki/teams/4765/wiki/czy/chrome-logo-czy.svg' style='height:2rem'>Chrome | <img src='https://static.igem.wiki/teams/4765/wiki/czy/safari-logo-czy.svg' style='height:2rem'>Safari | <img src='https://static.igem.wiki/teams/4765/wiki/czy/opera-logo-czy.svg' style='height:2rem'>Opera |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| IE9, IE10, IE11, Edge version≥116                            | version≥116                                                  | version≥116                                                  | version≥16.6                                                 | version≥101                                                  |

RAP provides a detailed [online](https://mistyfield.github.io/RAP-Docs/) as well as offline【pdf】 documentation.

Here are some animations to help you get acquainted with RAP.

### Tutorials

In this tutorial, it will be demonstrated how to use RAP to construct a pRAP sequence similar to BBa_K4765121 or BBa_K4765122. Click see more below to get the information you need. You can also directly access our pre-built [demo](http://54.169.242.254:5000/demo/) to generate the sequence.

::: details


| Name | Part ID                                                 | EC Number | $k_{cat}$ | Sequence                                                     |
| ---- | ------------------------------------------------------- | --------- | --------- | ------------------------------------------------------------ |
| galU | [BBa_K3331001](http://parts.igem.org/Part:BBa_K3331001) | 2.7.7.9   | 28.63     | [Click me](http://parts.igem.org/cgi/partsdb/composite_edit/putseq.cgi?part=BBa_K3331001) |
| pgmA | [BBa K3331002](http://parts.igem.org/Part:BBa_K3331002) | 5.4.2.2   | 109.27    | [Click me](http://parts.igem.org/cgi/partsdb/composite_edit/putseq.cgi?part=BBa_K3331002) |

:::

1. **Visit Home Page of RAP**

   If you visit our [live demo](http://54.169.242.254:5000/home) or `Home` page of RAP deployed through docker, you will see the page below:

   ![](https://static.igem.wiki/teams/4765/wiki/czy/rap-home.png)

2. **Run Step 1: KineticHub**

   The first step in constructing a pRAP system using RAP is to calculate the optimal enzyme concentration by KineticHub. The first step involves two tasks, i.e., searching target reaction and enzyme record for the reaction and constructing a cascade reaction, optimal ratio of enzymes based on the data will be returned after these two tasks.

   First, in the `KineticHub > Search Enzyme` page, enter the query and the type of keyword you want to retrieve.

   Here are some examples of query and the corresponding keyword types:

   | query           | keword type |
   | :-------------- | ----------- |
   | 1.1.1.101       | EC number   |
   | Nadh peroxidase | Name        |
   | Oxidation       | Type        |
   | alcohol         | Substrate   |
   | NADPH           | Product     |

   In order to search for the target enzyme more accurately, it is most recommended to use EC number to search for the enzyme. After typing in the query as well as selecting the keyword type and clicking `search`, you will see this interface:

   ![](https://static.igem.wiki/teams/4765/wiki/czy/kinetichub-result-czy.png)

   After clicking `Get Kcat`, the interface will look like this:

   ![](https://static.igem.wiki/teams/4765/wiki/czy/kcat-result-czy.png)

   Here you can get the species from which the enzyme is derived and its kinetic parameters in different environments with references, and you can check the appropriate record for your project and click on the plus icon. After that, return to the search results page, and you'll see that the flask icon in the upper right corner has added a little red dot.

   You have successfully imported one reaction! Now you need to add the remaining other reactions following this process.

   ::: tip
   If you haven't found the proper $k_{cat}$? You can add relevant experimental data into KineticHub to use it in `KineticHub > Add Enzyme` , if you don't you can use one of the machine learning based prediction methods online [here](https://turnup.cs.hhu.de/KCAT_pred_single) or using the [colab ipynb scripts](https://colab.research.google.com/gist/MistyField/3dd7af5e179b661c821c3b46c71d1b34/kcat_prediction.ipynb) we provide!
   :::

   After that, in the `KineticHub > Build reactions` page, enter the ratio of product to substrate stoichiometry for your reactions according to EC number and then click `Submit`.

   ![](https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-czy.png)

3. **Run Step 2: RAP Builder**

   After running Step 1, you can run Step 2 to generate pRAP sequence. In `RAP Builder` page, you can select design mode (RBS design mode/Stem loop design mode) and input the sequence of the enzyme. Then you can click `Submit` to run RAP Builder!

   ![](https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-demo-czy.png)

4. **Search Part in PartHub 2**

   To search Part with Parthub, you can go to `PartHub 2` page, input search query and select keyword type. The format of the search terms corresponding to different search types is as follows:

   | Search type | Meaning & Format                                             | Example           |
   | :---------- | :----------------------------------------------------------- | :---------------- |
   | ID          | The id of the part (e.g. BBa_xxxxxxxx). It is fine to enter a search term with or without BBa_. | K3790012          |
   | Name        | The name of the part in Registry of Standard Biological Parts. | GFP               |
   | Sequence    | The sequence of the part (if it exists). The search term can only be the combination of [a, t, g, c, A, T, G, C]. | TTAACTTTAAGAAGGAG |
   | Designer    | The name of the person who designed the part.                | Weiwen Chen       |
   | Team        | The name of the team which designed the part.                | Fudan             |
   | Content     | The content of the part in Registry of Standard Biological Parts. | carotene          |

   You can view the search results and see the Part you are interested in. If you click on the search result, you will see the network structure of the Part. You can scroll to zoom the canvas and drag to move the nodes. Click to display the part details and double click to go to the part page. On this page, you can also download the GeneBank format sequence of this part directly.

   <div style="text-align: center;">
       <img src="https://static.igem.wiki/teams/4765/wiki/parthub-demo.gif" style='width:80%'>
   </div>

## KineticHub

The first step in the optimization of cellular metabolism using the pRAP system is to determine the optimal enzyme concentration. For this purpose, we designed a model for calculating the optimal enzyme concentration, which is based on the following assumptions. We provide a summary of the notation in Table 2.

<div style="text-align: center;">
    <p>Table 2: A summary of the notation for KineticHub, with the corresponding descriptions.</p>
</div>


| Variable    | Description                                                 |
| :---------- | :---------------------------------------------------------- |
| $flux_n$    | flux of  $reaction_n$                                       |
| $[S_n]$     | concentration of the substrate of $reaction_n$              |
| $k_{m,n}$   | $k_m$ value of $reaction_n$                                 |
| $v_n$       | velocity value of $reaction_n$                              |
| $k_{cat,n}$ | $k_{cat}$ value of $reaction_n$                             |
| $A_n$       | ratio of product to substrate stoichiometry of $reaction_n$ |
| $c_n$       | optimal concentration of the enzyme of $reaction_n$         |

### Assumption 1

We expect the optimal state of cellular metabolism to be flux-balanced, when the fluxes of the reactions in the pRAP system should be equal, which can be expressed as

$$
flux_1 = flux_2 = ... = flux_n
$$
The significance of this assumption is that it prevents metabolic stress caused by flux imbalance and permits the cell to be in a state of flux balance.

### Assumption 2

The substrate should not be overstacked and should be kept more stationary, which we denote here as follows
$$
\frac{[S_1]}{k_{m,1}} = \frac{[S_2]}{k_{m,2}} = ... = \frac{[S_n]}{k_{m,n}}
$$
From the Michaelis-Menten equation we could find
$$
v_n = \frac{k_{cat,n}c_n[S_n]}{k_{m,n}+[S_n]}=\frac{k_{cat,n}c_n}{\frac{k_{m,n}}{[S_n]}+1}
$$
and $flux_n$ could be expressed as
$$
flux_n = v_n \times A_n
$$
Combining these equations and **Assumption 1** we can conclude
$$
c_n\propto\frac{1}{A_nk_{cat,n}}
$$
Therefore, we can calculate the optimal enzyme concentration based on the $k_{cat}$ of the enzyme. It is important to note that the purpose of regulating RBS strength here is to regulate the relative proportional coordination between exogenously imported reactions, and the regulation of the absolute strength of the linear reaction coupled to intracellular metabolism is controlled by the induction intensity. Since there is no database that specializes on the $k_{cat}$ of the enzyme, we created KineticHub to obtain the $k_{cat}$ of the enzyme and determine the optimal enzyme concentration. For a more detailed implementation please read our documentation and the source code.

### Implementation

We downloaded data from the open source (licensed under [Creative Commons Attribution License 4.0](https://creativecommons.org/licenses/by/4.0/)) version of [BRENDA](https://www.brenda-enzymes.org/download.php) as a data source for KineticHub. BRENDA enabled KineticHub to include more than 70,000 records and more than 7,000 EC numbers[^5]. But BRENDA provides text file containing BRENDA enzyme database, we need to parse and convert to the data type that the database can use. So we used and [contributed to](https://github.com/Robaina/BRENDApyrser/pull/8) a Python package (Figure 2) to parse and manipulate the BRENDA database: [BRENDApyrser](https://github.com/Robaina/BRENDApyrser)[^6], and ended up building KineticHub with MySQL.

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/pr-czy.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 2: Contribute to BRENDApyrser</small></p>
    </div>
</div>

The UML diagram of KineticHub is illustrated in Figure 3.For KineticHub, we created a set of RESTFul APIs using Flask that users can access both through our WebUI and by making direct API requests. An example notebook is available [here](https://gitlab.igem.org/2023/software-tools/fudan/-/blob/main/notebook/BRENDA_db.ipynb). For a more detailed implementation please read our [documentation](https://mistyfield.github.io/RAP-Docs/) and the source code.

## RAP Builder

As shown in workflow, after calculating the optimal enzyme concentration through KineticHub, the corresponding regulatory elements need to be designed through RAP Builder to form the sequence of the pRAP system. We developed a thermodynamic model and Monte Carlo algorithm for the design of the corresponding regulating elements. There are two modes in RAP Builder: RBS design mode and stem loop design mode. We provide a summary of the notation in Table 3.

<div style="text-align: center;">
    <p>Table 3: A summary of the notation for RAP Builder, with the corresponding descriptions.</p>
</div>


| Variable                 | Description                                                  |
| :----------------------- | :----------------------------------------------------------- |
| $[G_n]$                  | gene concentration of $reaction_n$                           |
| $\alpha_{p,n}$           | translation initiation rate of $reaction_n$                  |
| $\alpha_{m,n}$           | transcription initiation rate $reaction_n$                   |
| $\delta_{n}$             | mRNA degradation rate of $reaction_n$                        |
| $\lambda$                | growth rate of the cell                                      |
| $c_n$                    | optimal concentration of the enzyme of $reaction_n$          |
| $\Delta G_{total,n}$     | total free energy change of $reaction_n$                     |
| $\Delta G_{mRNA:rRNA,n}$ | free energy change when16S rRNA cofolds and hybridizes with the mRNA subsequence at the 16S rRNA-binding site of $reaction_n$ |
| $\Delta G_{start,n}$     | free energy change when anticodon hybridizes to the start codon of $reaction_n$ |
| $\Delta G_{spacing,n}$   | energetic penalty for a nonoptimal distance between the 16S rRNA-binding site and the start codon of $reaction_n$ |
| $\Delta G_{standby,n}$   | free enegy change when the standby site is folded of $reaction_n$ |
| $\Delta G_{mRNA,n}$      | the free energy change when mRNA is folded of of $reaction_n$ |
| $R$                      | gas constant                                                 |
| $T$                      | culture temperature                                          |

Protein concentration is affected by both translation initiation rate and mRNA degradation rate. We adopted and designed a cell-scale dynamic model (Figure 4) of transcription and translation[^7]. Here are some of the assumptions that RAP Builder is based on.

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-model.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 4: Model of transcription and translation</small></p>
    </div>
</div>


### Assumption 1

The dynamics of transcription and translation can be expressed as follows:
$$
\frac{d[mR_{n}]}{dt} = \alpha_{m,n}[G_n]-\delta_n[mR_i]
$$

$$
\frac{d[P_n]}{dt} = \alpha_{p,n}[mR_n]-\lambda[P_i]
$$

If we consider steady-state constraint, both $\frac{d[mR_{n}]}{dt}$ and $\frac{d[P_n]}{dt}$ are equal to $0$. We could conclude:
$$
\alpha_{m,n}[G_n]=\delta_n[mR_i]
$$

$$
\alpha_{p,n}[mR_n]=\lambda[P_i]
$$

Combining these two equations we can represent the relationship between protein concentration and transcription as well as translation below.
$$
c_n = \frac{\alpha_{p,n}}{\delta_n} \cdot \frac{\alpha_{m,n}[G_n]}{\lambda}
$$

### Assumption 2

Since the enzymes under pRAP system are all expressed under the same promoter, the gene concentration and transcription initiation rate are the same between reactions:
$$
[G_1] = [G_{2}] = ... = [G_n]
$$

$$
\alpha_{m,1} = \alpha_{m,2} = ... = \alpha_{m,n}
$$

Thus the concentration of protein is determined by $\alpha_{p,n}$ and $\delta_n$. RBS design mode quantitative controls $\alpha_{p,n}$ while the system loop design mode quantitative controls $\delta_n$.

**For RBS design mode:**
$$
\delta_1 = \delta_2 =...= \delta_n
$$
Based on **Assumption 1**, we can notice:
$$
\alpha_{p,n}\propto\frac{1}{A_nk_{cat,n}}
$$
**For stem loop design mode:**
$$
\alpha_{p,1} = \alpha_{p,2} = ... = \alpha_{p,n}
$$
Based on **Assumption 1**, we can notice:
$$
\delta_{n}\propto A_nk_{cat,n}
$$

### Assumption 3

Let's start with the RBS design mode. We employ a Gibbs free energy based thermodynamic model to predict the RBS intensity[^8]. If we decompose translation into individual processes, we can calculate $\Delta G_{total,n}$ like this:
$$
\Delta G_{total,n} = \Delta G_{final,n} - \Delta G_{initial,n}\\= \Delta G_{mRNA:rRNA,n} + \Delta G_{start,n} + \Delta G_{spacing,n} - \Delta G_{standby,n} - \Delta G_{mRNA,n}
$$
And the translation initiation rate could be presented by Boltzmann weight ($exp(\Delta G_{total,n}/ RT)$) through an emperical formula:
$$
\alpha_{p,n} = K \cdot exp(-\beta \Delta G_{total,n})
$$
where $K$ and $\beta$ are experimentally determined constants[^8]. The Monte Carlo algorithm enables us to predict and generate the synthetic RBS (see in Usage).

### Assumption 4

Then comes the stem loop design mode, similar to the RBS design mode, where we also use a thermodynamic model based on the Gibbs free energy to predict the stem loop intensity.



### Implementation

RAP Builder uses the open source [ViennaRNA package 2](https://github.com/ViennaRNA/ViennaRNA) for the necessary RNA secondary structure and free energy calculations[^9]. We refer to the Monte Carlo algorithm (Figure 5) in the open-source version of the [RBS Calculator](https://github.com/hsalis/Ribosome-Binding-Site-Calculator-v1.0) to achieve the generation of a suitable synthetic RBS[^10].

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/monte-carlo-trans.svg" style='width:40%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 5: Model of transcription and translation</small></p>
    </div>
</div>


We built the RAP Builder with Python 3.10. RAP Builder's Monte Carlo algorithm has a good search efficiency and can get a suitable sequence in a range of up to 1,000 iterations (Figure 6).

<div style="text-align: center;">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/monte-carlo-efficiency.svg" style='width:100%'>
  	<br>
    <div>
    	<p><small style="color: gray">Figure 6: The Efficiency of RBS searching by monte carlo algorithm. The ddG means difference between dG target and current dG.</small></p>
    </div>
</div>


The Monte Carlo algorithm of stem loop design mode is similar to that used in RBS design mode. Meanwhile, RAP Builder is packed into a python package, which can be accessed [here](https://pypi.org/project/rapBuilder/). RAP Builder also support RESTful APIs developed by Flask. For more details here is a [example notebook](https://gitlab.igem.org/2023/software-tools/fudan/-/blob/main/notebook/rapBuilder_demo.ipynb) to demonstrate the generation of synthetic RBS. RAP Builder generates GeneBank-formatted sequence files from Biopython and an annotation file that generates annotations for each sequence in the project and can be opened directly with external tools such as SnapGene (Figure 7).

## Parthub 2

Fudan iGEM 2022 witnessed the success of [PartHub](https://2022.igem.wiki/fudan/software), so this year Fudan iGEM 2023 gathered feedback from PartHub users (Fudan iGEM 2022 team members and other iGEMers and some judges in 2022 Grand Jamboree), resolved known issues, and launched the brand new PartHub 2! Compared to Parthub, PartHub 2 has several new features:

- Update with 2022 iGEM Registery of Standard Biological Parts. Parthub 2 contains over 60,000 Parts, which is a huge leap up from Parthub.
- Improve the user interaction interface to further simplify the process of usage. PartHub 2 incorporates feedback and suggestions from PartHub users, removes unnecessary options and starts developing recommendation algorithms.
- Design a diversified recommendation algorithm based on graph algorithm. We developed a diversified recommendation algorithm based on PageRank and Louvain method to prioritize the appearance of more significant parts in the search results and avoid the recurrence of similar parts.

The core of PartHub 2 is the graph model based on the Registery of Standard Biological Parts. For each Part, in addition to the attributes (like name, sequence etc.) it carries, there are two types of relationships with other nodes: "twins" and "refers to". The "twins" are undirected, while the "refers to" are directed; each is a data structure known as graph, and their relationships may be represented by an adjacency matrix. PageRank and Louvain method is based on this graph model. PageRank reflects how actively a Part is used and Louvain enables community detection of similar Parts.

We provide a summary of the notation in Table 4.

<div style="text-align: center;">
    <p>Table 4: A summary of the notation for PartHub 2, with the corresponding descriptions.</p>
</div>

| Variable  | Description                                                  |
| --------- | ------------------------------------------------------------ |
| $d$       | damping factor which can be set between 0 (inclusive) and 1 (exclusive) |
| $Q$       | modularity of a graph                                        |
| $k_i,k_j$ | the sum of the weights of the edges attached to $community_i$ and $community_j$ |
| $m$       | sum of all of the edge weights in the graph                  |
| $c_i,c_j$ | communities of the nodes                                     |

### PageRank

The PageRank algorithm[^11] evaluates the relevance of each node in the network based on the number of incoming relationships and the importance of the associated source nodes. In general, the underlying notion is that a node is only as important as the nodes that link to it. We assume that a node $A$ has node $T_1$ to $T_n$ which point to it. PageRank is introduced as a function that solves the following equation:
$$
PageRank(A) = (1-d)+d\sum_{i=1}^n \frac{PageRank(T_i)}{C(T_i)}
$$
where $C(A)$ is the number of links going out of node *A*. This equation is used to update a candidate solution iteratively and arrive at an approximate solution. By calculating the PageRank of each node, the centrality of each Part can be defined as well as represented.

### Louvain Method

The Louvain method[^12] is a community detection method suitable for huge networks. It maximizes a modularity score for each community, where modularity measures the quality of node assignment. This entails determining how much more densely connected nodes within a community are in comparison to how connected they would be in a random network.

In Louvain method, modularity $Q$ of a graph is defined as:
$$
Q = \frac{1}{2m}\sum_{i,j}[A_{i,j}-\frac{k_ik_j}{2m}]\delta(c_i,c_j)
$$
where $A_{i,j}$ is the edge weight between $community_i$ and $community_j$ and $\delta(x,y)$ is Kronecker delta function ($\delta(x,y)=1$ if $x=y$ else $0$).

Louvain algorithm needs to be repeated for two phases to greedily maximize modularity. Phase 1 will put each node in a graph into a distinct community and optimize modularity by allowing only local changes to node-communities memberships. Phase 2 will aggregate communities into super-nodes to build a new network. The new network of super-nodes will then run Phase 1. Phase 1 and Phase 2 will be repeated until no movement yields a gain on the sum of modularity of all communities.

### Implementation

We used a [web crawler](https://gitlab.igem.org/2022/software-tools/fudan/-/blob/main/WebCrawler/software_ver0.4.py) to obtain Parts in 2022 iGEM Registery of Standard Biological Parts. We used Neo4j as the graph database for PartHub 2, and Flask to develop RESTful APIs for PartHub 2. PageRank and Louvain method was performed with Neo4j Graph Data Science (GDS) library. Like RAP Builder, PartHub 2 supports exporting GeneBank format sequence files via Biopython.

## DBTL cycles of RAP

RAP strictly follows [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) and [Semantic Versioning 2.0.0](https://semver.org/). The development of RAP has gone through several DBTL cycles, and changelog has witnessed the development process of RAP as well as its releases. For more information on DBTL cycles of RAP, please visit xxx.

## References

[^1]: Kim, K.-J., Kim, H.-E., Lee, K.-H., Han, W., Yi, M.-J., Jeong, J., & Oh, B.-H. (2004). Two-promoter vector is highly efficient for overproduction of protein complexes. *Protein Science: A Publication of the Protein Society*, *13*(6), 1698–1703. https://doi.org/10.1110/ps.04644504
[^2]: Liu, Y., Wu, Z., Wu, D., Gao, N., & Lin, J. (2023). Reconstitution of Multi-Protein Complexes through Ribozyme-Assisted Polycistronic Co-Expression. *ACS Synthetic Biology*, *12*(1), 136–143. https://doi.org/10.1021/acssynbio.2c00416
[^3]: Newbury, S. F., Smith, N. H., & Higgins, C. F. (1987). Differential mRNA stability controls relative gene expression within a polycistronic operon. *Cell*, *51*(6), 1131–1143. https://doi.org/10.1016/0092-8674(87)90599-x
[^4]: Sokolenko, S., George, S., Wagner, A., Tuladhar, A., Andrich, J. M. S., & Aucoin, M. G. (2012). Co-expression vs. co-infection using baculovirus expression vectors in insect cell culture: Benefits and drawbacks. *Biotechnology Advances*, *30*(3), 766–781. https://doi.org/10.1016/j.biotechadv.2012.01.009
[^5]: Chang, A., Jeske, L., Ulbrich, S., Hofmann, J., Koblitz, J., Schomburg, I., Neumann-Schaal, M., Jahn, D., & Schomburg, D. (2021). BRENDA, the ELIXIR core data resource in 2021: New developments and updates. *Nucleic Acids Research*, *49*(D1), D498–D508. https://doi.org/10.1093/nar/gkaa1025
[^6]: Estévez, S. R. (2022). *Robaina/BRENDApyrser: Zenodo* [Computer software]. Zenodo. https://doi.org/10.5281/zenodo.7026555
[^7]: Balakrishnan, R., Mori, M., Segota, I., Zhang, Z., Aebersold, R., Ludwig, C., & Hwa, T. (2022). Principles of gene regulation quantitatively connect DNA to RNA and proteins in bacteria. *Science (New York, N.Y.)*, *378*(6624), eabk2066. https://doi.org/10.1126/science.abk2066
[^8]: Salis, H. M., Mirsky, E. A., & Voigt, C. A. (2009). Automated design of synthetic ribosome binding sites to control protein expression. *Nature Biotechnology*, *27*(10), Article 10. https://doi.org/10.1038/nbt.1568
[^9]: Lorenz, R., Bernhart, S. H., Höner zu Siederdissen, C., Tafer, H., Flamm, C., Stadler, P. F., & Hofacker, I. L. (2011). ViennaRNA Package 2.0. *Algorithms for Molecular Biology*, *6*(1), 26. https://doi.org/10.1186/1748-7188-6-26
[^10]: Salis, H. (2023). *Hsalis/Ribosome-Binding-Site-Calculator-v1.0* [Python]. https://github.com/hsalis/Ribosome-Binding-Site-Calculator-v1.0 (Original work published 2009)
[^11]: Brin, S., & Page, L. (1998). The anatomy of a large-scale hypertextual Web search engine. *Computer Networks and ISDN Systems*, *30*(1), 107–117. https://doi.org/10.1016/S0169-7552(98)00110-X
[^12]: Blondel, V. D., Guillaume, J.-L., Lambiotte, R., & Lefebvre, E. (2008). Fast unfolding of communities in large networks. *Journal of Statistical Mechanics: Theory and Experiment*, *2008*(10), P10008. https://doi.org/10.1088/1742-5468/2008/10/P10008

