---
sidebar: auto
title: Software
author:
   - Zhiyue Chen
authorlink:
   - /fudan/team/#zhiyue-chen-the-software-wizard
---

::: tip
Live demo of RAP is available. Visit our live demo [here](http://54.169.242.254:5000/)!
:::

## Overview

### Highlights

- Intuitive WebUI with APIs for advanced development
- Compatible with and leveraging GeneBank format and easy integration with SnapGene
- Support throughout the DBTL cycle
- Experimentally validated results
- Comprehensive documentation and tutorials

Improving chassis metabolism is crucial for applications in synthetic biology. And the design of most synthetic biology applications involves multiple enzymes working together to form a cascade reaction. Flux imbalance frequently occur in unoptimized cascade reactions, which may lead to problems like the appearance of the speed limit step, the occurrence of metabolic stress on cells, and the accumulation of cytotoxic intermediates. The success of the Ribozyme-Assisted Polycistronic co-expression system (pRAP system) and the benefits of replacing multiple promoter co-expression system in improving chassis metabolism have been demonstrated by [Fudan iGEM 2022](http://parts.igem.org/Part:BBa_K4162005). How ever, the Fudan iGEM 2022 has two drawbacks for the usage of the pRAP system:

1. Lack of **quantitative** regulation for the pRAP system. Fudan iGEM 2022 regulates the expression of different proteins in pRAP by qualitatively changing the intensity of ribosome binding site (RBS).
2. Only focusing on ribosome binding but without attention to **mRNA degradation**.

This year, we developed a quantitative pRAP system design software for all regulatory elements, which could support the entire Design-Build-Test-Learn cycle (DBTL cycle): **RAP**. RAP consists of three parts: [KineticHub](#kinetichub), [RAP Builder](#rap-builder) and [PartHub 2](#parthub-2). The functions of RAP incorporate:

- **Parts searching**
- **Calculation of optimal concentrations of enzymes**
- **pRAP system sequence construction**

RAP has made a number of efforts to improve the user experience. To make RAP more user-friendly, we have designed an intuitive Web UI with tutorials, and for advanced usage of RAP, we have provided a series of RESTFul APIs, and for better use of sequences generated by RAP, we have adopted the GeneBank format to save sequences, which is an existing synthetic biology standards, and the sequences can be used in external tools such as SnapGene. In order to get feedback from users other than the Fudan iGEM 2023 team members to increase user-friendliness, we have [collaborated](https://2023.igem.wiki/fudan/collaborations/#with-scut-china-nju-china-software-discussion) with other iGEM teams (SCUT-China iGEM 2023 & Nanjing-China iGEM 2023) to improve RAP. Meanwhile, RAP is validated by a series of experimental results.

RAP has gone through several [DBTL cycles](/engineering/), leading to a concise workflow for RAP ([Figure 1](#fig-1)).

<div style="text-align: center;" id="fig-1">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-workflow.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 1: Workflow of RAP</small></p>
    </div>
</div>

In summary, RAP has led to a revolution in gene circuit design, offering new perspectives as well as strategies for handling the flux optimization. The source code is freely available at the repository [https://gitlab.igem.org/2023/software-tools/fudan](https://gitlab.igem.org/2023/software-tools/fudan).

## Principles of pRAP system

It is indicated that the major problem of polycistronic vectors, which contain two or more target genes under one promoter, is the much lower expression of the downstream genes compared with that of the first gene next to the promoter[^1]. Compared with multiple promoter system, self-interaction of the polycistron can be avoid and each cistron can initiate translation with comparable efficiency. So we need to employ pRAP system instead of adopting multiple promoter strategy or assembling CDSs sequentially. In pRAP system ([Figure 2](#fig-2)), the RNA sequences of hammerhead ribozyme conduct self-cleaving, and the polycistronic mRNA transcript is thus co-transcriptionally converted into individual mono-cistrons *in vivo*[^2] .

<div style="text-align: center;" id="fig-2">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/prap-1-czy.png" style='width:80%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 2: Principle of pRAP system</small></p>
    </div>
</div>

In the pRAP system, there are two regulatory elements: **RBS** and **stem loop**. RBS intensity influences translation initiation rate by influencing ribosome binding to mRNA, which in turn impacts protein concentration. Stem loop affects protein concentration by regulating the rate of mRNA degradation[^3]. By regulating the intensity of these two regulatory elements, we can control the expression of proteins. For more details on building pRAP system, please refer to [RAP Builder](#rap-builder).

Compared to the multi-promoter strategy,  pRAP system has three other advantages:

1. **Minor changes** in genetic circuit. Since the regulatory elements are not in the CDS, designing a pRAP system only requires adding regulatory elements upstream and downstream of the CDS, which is "**painless**" for most project requirements.
2. Polycistronic expression provides **reproducible ratios** of the synthesized proteins, mitigating the effect on protein expression of the fluctuating transcription associated with multiple promoters [^4].
3. **Minimal cargo DNA** are required to deliver multiple genes for the application of synthetic biology.

For more details about pRAP system, please visit here介绍pRAP.

## Web UI

The need of user interface improvements were mentioned in several Learn phases of the DBTL cycles during the development of  RAP, so we end up  developing an intuitive but powerful Web UI for RAP. Web UI of RAP has good compatibility and support the following browsers ([Table 1](#table-1)).

<div style="text-align: center;" id="table-1">
    <p>Table 1: Browsers support of the Web UI (until Oct 2023)</p>
</div>

| <img src='https://static.igem.wiki/teams/4765/wiki/czy/edge-logo-czy.svg' style='height:2rem'>IE / Edge | <img src='https://static.igem.wiki/teams/4765/wiki/czy/firefox-logo-czy.svg' style='height:2rem'>Firefox | <img src='https://static.igem.wiki/teams/4765/wiki/czy/chrome-logo-czy.svg' style='height:2rem'>Chrome | <img src='https://static.igem.wiki/teams/4765/wiki/czy/safari-logo-czy.svg' style='height:2rem'>Safari | <img src='https://static.igem.wiki/teams/4765/wiki/czy/opera-logo-czy.svg' style='height:2rem'>Opera |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| IE9, IE10, IE11, Edge version≥116                            | version≥116                                                  | version≥116                                                  | version≥16.6                                                 | version≥101                                                  |

RAP provides a detailed [online](https://mistyfield.github.io/RAP-Docs/) and offline【pdf】 documentation and you can get the source code of Web UI [here](https://gitlab.igem.org/2023/software-tools/fudan/-/tree/main/webUI). Web UI is based on [Vue.js](https://vuejs.org/), using [Ant Design Vue](https://antdv.com/docs/vue/introduce) as the front-end component library and [Axios](https://axios-http.com/) to access and process the APIs. [Neovis.js](https://github.com/neo4j-contrib/neovis.js) was used to visualize the network structure in PartHub 2.

### Tutorials

In this tutorial, we will demonstrate the utilization of RAP for the purpose of constructing pRAP sequence similar to [BBa_K4765121](http://parts.igem.org/Part:BBa_K4765121) or [BBa_K4765122](http://parts.igem.org/Part:BBa_K4765122). To obtain the requisite information (refer to Table S1), click “see more“ below. Alternatively, you can directly access our pre-built [demo](http://54.169.242.254:5000/demo/) to generate the sequence.

::: details

<div style="text-align: center;">
    <p>Table S1: Information for the tutorials of Web UI</p>
</div>

| Name | Part ID                                                 | EC Number | $k_{cat}$ | Sequence                                                     |
| ---- | ------------------------------------------------------- | --------- | --------- | ------------------------------------------------------------ |
| galU | [BBa_K3331001](http://parts.igem.org/Part:BBa_K3331001) | 2.7.7.9   | 28.63     | [Click me](http://parts.igem.org/cgi/partsdb/composite_edit/putseq.cgi?part=BBa_K3331001) |
| pgmA | [BBa K3331002](http://parts.igem.org/Part:BBa_K3331002) | 5.4.2.2   | 109.27    | [Click me](http://parts.igem.org/cgi/partsdb/composite_edit/putseq.cgi?part=BBa_K3331002) |

:::

1. **Visit Home Page of RAP**

   Upon visiting our [live demo](http://54.169.242.254:5000/home) or `Home` page of RAP deployed through docker, you will see the page below ([Figure 3](#fig-3)):

   <div style="text-align: center;" id="fig-3">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-home.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 3: Home page of RAP</small></p>
       </div>
   </div>

2. **Run Step 1: KineticHub**

   The first step in constructing a pRAP system using RAP is to calculate the optimal enzyme concentration by KineticHub. The first step involves two tasks, i.e., searching target reaction and enzyme record for the reaction and constructing a cascade reaction, optimal ratio of enzymes based on the data will be returned after these two tasks.

   First, in the `KineticHub > Search Enzyme` page, please enter the query and the type of keyword you want to retrieve.

   Here are some examples of query and the corresponding keyword types ([Table 2](#table-2)):

   <div style="text-align: center;" id="table-2">
       <p>Table 2: Examples of query and corresponding keyword types</p>
   </div>

   | Keword Type | Meaning & Format                                             | Query           |
   | ----------- | ------------------------------------------------------------ | --------------- |
   | EC number   | EC number of the reaction (e.g. x.y.z.w), it's fine to just enter part of the EC number | 1.1.1.101       |
   | Name        | The name of the reaction                                     | Nadh peroxidase |
   | Type        | Reaction type                                                | Oxidation       |
   | Substrate   | One of the possible substrate of the reaction                | alcohol         |
   | Product     | One of the possible product of the reaction                  | NADPH           |

   In order to search for the target enzyme more accurately, it is most recommended to use EC number to search for the enzyme. you will be presented with the interface as illustrated in [Figure 4](https://chat.openai.com/c/ed5dc932-7422-4fe6-b666-d0a109d87941#fig-4):

   <div style="text-align: center;" id="fig-4">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/kinetichub-result-czy.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 4: Search result of KineticHub for reactions</small></p>
       </div>
   </div>

   After clicking `Get Kcat`, the interface will be represented like [Figure 5](#fig-5):

   <div style="text-align: center;" id="fig-5">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/kcat-result-czy.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 5: Search result of KineticHub for kcat</small></p>
       </div>
   </div>

   Here you can get the species from which the enzyme is derived and its kinetic parameters in different environments with references, and you can check the appropriate record for your project and click on the plus icon. After that, return to the search results page, and you'll see that the flask icon in the upper right corner has added a little red dot.

   You have successfully imported one reaction! Now you need to add the remaining other reactions following this process.

   ::: tip
   If you haven't found the proper $k_{cat}$? You can add relevant experimental data into KineticHub to use it in `KineticHub > Add Enzyme` , if you don't you can use one of the machine learning based prediction methods online [here](https://turnup.cs.hhu.de/KCAT_pred_single) or using the [colab ipynb scripts](https://colab.research.google.com/gist/MistyField/3dd7af5e179b661c821c3b46c71d1b34/kcat_prediction.ipynb) we provide!
   :::

   After that, in the `KineticHub > Build reactions` page ([Figure 6](#fig-6)), please enter the ratio of product to substrate stoichiometry for your reactions according to EC number and then click `Submit` button.

   <div style="text-align: center;" id="fig-6">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-czy.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 6: Building reactions in KineticHub</small></p>
       </div>
   </div>

3. **Run Step 2: RAP Builder**

   In `RAP Builder` page ([Figure 7](#fig-7)), you can select design mode (RBS/Stem loop design mode) and input the sequence of the enzyme. Then you can click `Submit` button to run RAP Builder! After completion of RAP Builder, the results will be automatically downloaded, containing a sequence file in `GeneBank` format and an annotation in `csv` format.

   <div style="text-align: center;" id="fig-7">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-demo-czy.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 7: Running RAP Builder</small></p>
       </div>
   </div>

4. **Search Part in PartHub 2**

   To search Part with Parthub, you can navigate to the `PartHub 2` page ([Figure 8](#fig-8)). Subsequently, please input your search query and select the appropriate keyword type as required.

   <div style="text-align: center;" id="fig-8">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/parthub-search.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 8: PartHub 2</small></p>
       </div>
   </div>

The examples and meaning of the search terms corresponding to search types is as follows ([Table 3](#table-3)):

<div style="text-align: center;" id="table-3">
       <p>Table 3: Examples and meaning of the search terms corresponding to search types</p>
   </div>

| keyword type | Meaning & Format                                             | Example           |
| :----------- | :----------------------------------------------------------- | :---------------- |
| ID           | The id of the part (e.g. BBa_xxxxxxxx). It is fine to enter a search term with or without BBa_ | K3790012          |
| Name         | The name of the part in Registry of Standard Biological Parts | GFP               |
| Sequence     | The sequence of the part (if it exists). The search term can only be the combination of [a, t, g, c, A, T, G, C] | TTAACTTTAAGAAGGAG |
| Designer     | The name of the person who designed the part                 | Weiwen Chen       |
| Team         | The name of the team which designed the part                 | Fudan             |
| Content      | The content of the part in Registry of Standard Biological Parts | carotene          |

You have the option to peruse the search results and access the Part you are interested in ([Figure 9](#fig-9)).

   <div style="text-align: center;" id="fig-9">
       <img src="https://static.igem.wiki/teams/4765/wiki/czy/parthub-result.png" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 9: Search results of PartHub 2</small></p>
       </div>
   </div>

By clicking on a search result, you will be presented with the network structure of the Part. You can scroll to zoom the canvas and drag to move the nodes ([Figure 10](#fig-10)). Furthermore, clicking on a node will display detailed information about the Part, while double-clicking will lead you to the dedicated Part page. On this page, you will also have the convenience of directly downloading the GeneBank format sequence for the selected Part.

   <div style="text-align: center;" id="fig-10">
       <img src="https://static.igem.wiki/teams/4765/wiki/parthub-demo.gif" style='width:80%'>
       <br>
       <div>
       	<p><small style="color: gray">Figure 10: Parts network of PartHub 2</small></p>
       </div>
   </div>

## KineticHub

The first step in the optimization of intracellular metabolism using the pRAP system is to determine the optimal enzyme concentration. For this purpose, we designed a model for calculating the optimal enzyme concentration, which is based on the following assumptions. We provide a summary of the notation in [Table 4](#table-4).

<div style="text-align: center;" id="table-4">
    <p>Table 4: A summary of the notation for KineticHub, with the corresponding descriptions.</p>
</div>

| Variable    | Description                                                 |
| :---------- | :---------------------------------------------------------- |
| $flux_n$    | flux of  $reaction_n$                                       |
| $[S_n]$     | concentration of the substrate of $reaction_n$              |
| $k_{m,n}$   | $k_m$ value of $reaction_n$                                 |
| $v_n$       | velocity value of $reaction_n$                              |
| $k_{cat,n}$ | $k_{cat}$ value of $reaction_n$                             |
| $A_n$       | ratio of product to substrate stoichiometry of $reaction_n$ |
| $c_n$       | optimal concentration of the enzyme of $reaction_n$         |

### Assumption 1

We expect the optimal state of intracellular metabolism to be flux-balanced, so we should take steady-state constraint into consideration, which can be expressed as:

$$
flux_1 = flux_2 = ... = flux_n
$$
The significance of this assumption is that it prevents metabolic stress caused by flux imbalance and permits the cell to be in a state of flux balance.

### Assumption 2

The substrate should not be overstacked and should be kept more stationary, which we denote here as follows:
$$
\frac{[S_1]}{k_{m,1}} = \frac{[S_2]}{k_{m,2}} = ... = \frac{[S_n]}{k_{m,n}}
$$
From the Michaelis-Menten equation we could find:
$$
v_n = \frac{k_{cat,n}c_n[S_n]}{k_{m,n}+[S_n]}=\frac{k_{cat,n}c_n}{\frac{k_{m,n}}{[S_n]}+1}
$$
and $flux_n$ could be expressed as:
$$
flux_n = v_n \times A_n
$$
Combining these equations and **Assumption 1** we can conclude:
$$
c_n\propto\frac{1}{A_nk_{cat,n}}
$$
Therefore, we can calculate the optimal enzyme concentration based on the $k_{cat}$ of the enzyme. It is important to note that the purpose of regulating RBS strength here is to regulate the relative proportional coordination between exogenously imported reactions, and the regulation of the absolute strength of the cascade reaction coupled to intracellular metabolism is controlled by the induction intensity. Since there is no database that specializes on the $k_{cat}$ of the enzyme, we created **KineticHub** to obtain the $k_{cat}$ of the enzyme and determine the optimal enzyme concentration. For a more detailed implementation please read our documentation and the [source code](https://gitlab.igem.org/2023/software-tools/fudan/-/tree/main/webUI).

### Implementation

We downloaded data from the open source (licensed under [Creative Commons Attribution License 4.0](https://creativecommons.org/licenses/by/4.0/)) version of [BRENDA](https://www.brenda-enzymes.org/download.php) as a data source for KineticHub. BRENDA enabled KineticHub to include more than 70,000 records and more than 7,000 EC numbers[^5]. But BRENDA provides text file containing BRENDA enzyme database, we need to parse and convert to the data type that the database can use. So we used and [contributed to](https://github.com/Robaina/BRENDApyrser/pull/8) a Python package ([Figure 11](#fig-11)) to parse and manipulate the BRENDA database: [BRENDApyrser](https://github.com/Robaina/BRENDApyrser)[^6], and ended up building KineticHub with MySQL.

<div style="text-align: center;" id="fig-11">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/pr-czy.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 11: Contribute to BRENDApyrser</small></p>
    </div>
</div>

The Unified Modeling Language (UML) diagram of KineticHub is illustrated in [Figure 12](#fig-12).

<div style="text-align: center;" id="fig-12">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/kinetichub-uml.svg" style='width:80%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 12: UML diagram of KineticHub</small></p>
    </div>
</div>

For KineticHub, we created a set of RESTFul APIs using Flask that users can access both through our Web UI and by making direct API requests. An example notebook is available [here](https://gitlab.igem.org/2023/software-tools/fudan/-/blob/main/notebook/BRENDA_db.ipynb). In order to facilitate the installation of KineticHub on different platforms, we have also created the corresponding docker image.

## RAP Builder

As shown in workflow, after calculating the optimal enzyme concentration through KineticHub, the corresponding regulatory elements need to be designed through RAP Builder to form the sequence of the pRAP system. We developed a thermodynamic model and Monte Carlo algorithm for the design of the corresponding regulating elements. There are two modes in RAP Builder: RBS design mode and stem loop design mode. We provide a summary of the notation in [Table 5](#table-5).

<div style="text-align: center;" id="table-5">
    <p>Table 5: A summary of the notation for RAP Builder, with the corresponding descriptions.</p>
</div>

| Variable                 | Description                                                  |
| :----------------------- | :----------------------------------------------------------- |
| $[G_n]$                  | gene concentration of $reaction_n$                           |
| $[mR_{n}]$               | mRNA concentration of $reaction_n$                           |
| $[P_{n}]$                | protein concentration of $reaction_n$                        |
| $\alpha_{p,n}$           | translation initiation rate of $reaction_n$                  |
| $\alpha_{m,n}$           | transcription initiation rate $reaction_n$                   |
| $\delta_{n}$             | mRNA degradation rate of $reaction_n$                        |
| $\lambda$                | growth rate of the cell                                      |
| $c_n$                    | optimal concentration of the enzyme of $reaction_n$          |
| $\Delta G_{total,n}$     | total free energy change of $reaction_n$                     |
| $\Delta G_{mRNA:rRNA,n}$ | free energy change when16S rRNA cofolds and hybridizes with the mRNA subsequence at the 16S rRNA-binding site of $reaction_n$ |
| $\Delta G_{start,n}$     | free energy change when anticodon hybridizes to the start codon of $reaction_n$ |
| $\Delta G_{spacing,n}$   | energetic penalty for a nonoptimal distance between the 16S rRNA-binding site and the start codon of $reaction_n$ |
| $\Delta G_{standby,n}$   | free energy change when the standby site is folded of $reaction_n$ |
| $\Delta G_{mRNA,n}$      | the free energy change when mRNA is folded of of $reaction_n$ |
| $R$                      | gas constant                                                 |
| $T$                      | culture temperature                                          |

Protein concentration is affected by both translation initiation rate and mRNA degradation rate. We adopted and designed a cell-scale dynamic model ([Figure 13](#fig-13)) of transcription and translation[^7]. Here are some of the assumptions that RAP Builder is based on.

<div style="text-align: center;" id="fig-13">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/rap-builder-model.png" style='width:100%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 13: Model of transcription and translation</small></p>
    </div>
</div>

### Assumption 1

The dynamics of transcription and translation can be expressed as follows:
$$
\frac{d[mR_{n}]}{dt} = \alpha_{m,n}[G_n]-\delta_n[mR_i]
$$

$$
\frac{d[P_n]}{dt} = \alpha_{p,n}[mR_n]-\lambda[P_i]
$$

If we consider steady-state constraint, both $\frac{d[mR_{n}]}{dt}$ and $\frac{d[P_n]}{dt}$ are equal to $0$. We could conclude:
$$
\alpha_{m,n}[G_n]=\delta_n[mR_i]
$$

$$
\alpha_{p,n}[mR_n]=\lambda[P_i]
$$

Combining these two equations we can represent the relationship between protein concentration and transcription as well as translation below:
$$
c_n = \frac{\alpha_{p,n}}{\delta_n} \cdot \frac{\alpha_{m,n}[G_n]}{\lambda}
$$

### Assumption 2

Since the enzymes under pRAP system are all expressed under the same promoter, the gene concentration and transcription initiation rate are the same between reactions:
$$
[G_1] = [G_{2}] = ... = [G_n]
$$

$$
\alpha_{m,1} = \alpha_{m,2} = ... = \alpha_{m,n}
$$

Thus the concentration of protein is determined by $\alpha_{p,n}$ and $\delta_n$. RBS design mode quantitative controls $\alpha_{p,n}$ while the system loop design mode quantitative controls $\delta_n$.

**For RBS design mode:**
$$
\delta_1 = \delta_2 =...= \delta_n
$$
Based on **Assumption 1**, we can notice:
$$
\alpha_{p,n}\propto\frac{1}{A_nk_{cat,n}}
$$
**For stem loop design mode:**
$$
\alpha_{p,1} = \alpha_{p,2} = ... = \alpha_{p,n}
$$
Based on **Assumption 1**, we can notice:
$$
\delta_{n}\propto A_nk_{cat,n}
$$

### Assumption 3

Let's start with the RBS design mode. We employ a Gibbs free energy based thermodynamic model to predict the RBS intensity[^8]. If we decompose translation into individual processes, we can calculate $\Delta G_{total,n}$ like this:
$$
\Delta G_{total,n} = \Delta G_{final,n} - \Delta G_{initial,n}\\= \Delta G_{mRNA:rRNA,n} + \Delta G_{start,n} + \Delta G_{spacing,n} - \Delta G_{standby,n} - \Delta G_{mRNA,n}
$$
And the translation initiation rate could be presented by Boltzmann weight ($exp(\Delta G_{total,n}/ RT)$) through an empirical formula:
$$
\alpha_{p,n} = K \cdot exp(-\beta \Delta G_{total,n})
$$
where $K$ and $\beta$ are experimentally determined constants[^8]. The Monte Carlo algorithm enables us to predict and generate the synthetic RBS (see in Usage).

### Assumption 4

Then comes the stem loop design mode, similar to the RBS design mode, where we also use a thermodynamic model based on the Gibbs free energy to predict the stem loop intensity.

### Implementation

RAP Builder uses the open source [ViennaRNA package 2](https://github.com/ViennaRNA/ViennaRNA) for the necessary RNA secondary structure and free energy calculations[^9]. We refer to the Monte Carlo algorithm ([Figure 14](#fig-14)) in the open-source version of the [RBS Calculator](https://github.com/hsalis/Ribosome-Binding-Site-Calculator-v1.0) to achieve the generation of a suitable synthetic RBS[^10].

<div style="text-align: center;" id="fig-14">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/monte-carlo-trans.svg" style='width:40%'>
    <br>
    <div>
    	<p><small style="color: gray">Figure 14: Model of transcription and translation</small></p>
    </div>
</div>

We built the RAP Builder with Python 3.10. RAP Builder's Monte Carlo algorithm has a good search efficiency and can get a suitable sequence in a range of up to 1,000 iterations ([Figure 15](#fig-15)).

<div style="text-align: center;" id="fig-15">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/monte-carlo-efficiency.svg" style='width:50%'>
  	<br>
    <div>
    	<p><small style="color: gray">Figure 15: The Efficiency of RBS searching by Monte Carlo algorithm. The ddG means difference between dG target and current dG.</small></p>
    </div>
</div>

The Monte Carlo algorithm of stem loop design mode is similar to that used in RBS design mode. Meanwhile, RAP Builder is packed into a python package, which can be accessed [here](https://pypi.org/project/rapBuilder/). RAP Builder also support RESTful APIs developed by Flask. For more details here is a [example notebook](https://gitlab.igem.org/2023/software-tools/fudan/-/blob/main/notebook/rapBuilder_demo.ipynb) to demonstrate the generation of synthetic RBS. Similar to KineticHub, we've made docker images for easier installation.RAP Builder generates GeneBank-formatted sequence files from [Biopython](https://biopython.org/) and an annotation file that generates annotations for each sequence in the project and can be opened directly with external tools such as SnapGene ([Figure 16](#fig-16)).

<div style="text-align: center;" id="fig-16">
    <img src="https://static.igem.wiki/teams/4765/wiki/czy/snap-gene.png" style='width:80%'>
  	<br>
    <div>
    	<p><small style="color: gray">Figure 16: Integration with SnapGene</small></p>
    </div>
</div>


## Parthub 2

Fudan iGEM 2022 witnessed the success of [PartHub](https://2022.igem.wiki/fudan/software), so this year we gathered feedback from PartHub users (Fudan iGEM 2022 team members and other iGEMers and some judges in 2022 Grand Jamboree), resolved known issues, and launched the brand new PartHub 2! Compared to Parthub, PartHub 2 has several new features:

- Update with 2022 iGEM Registery of Standard Biological Parts. Parthub 2 contains over 60,000 Parts, which is a huge leap up from Parthub.
- Improve the user interaction interface to further simplify the process of usage. PartHub 2 incorporates feedback and suggestions from PartHub users, removes unnecessary options and starts developing recommendation algorithms.
- Design a diversified recommendation algorithm based on graph algorithm. We developed a diversified recommendation algorithm based on PageRank and Louvain method to prioritize the appearance of more significant parts in the search results and avoid the recurrence of similar parts.

The core of PartHub 2 is the graph model based on the Registry of Standard Biological Parts. For each Part, in addition to the attributes (like name, sequence etc.) it carries, there are two types of relationships with other nodes: "twins" and "refers to". The "twins" are undirected, while the "refers to" are directed; each is a data structure known as graph, and their relationships may be represented by an adjacency matrix. PageRank and Louvain method is based on this graph model. PageRank reflects how actively a Part is used and Louvain enables community detection of similar Parts.

We provide a summary of the notation in [Table 6](#table-6).

<div style="text-align: center;" id="table-6">
    <p>Table 6: A summary of the notation for PartHub 2, with the corresponding descriptions.</p>
</div>

| Variable  | Description                                                  |
| --------- | ------------------------------------------------------------ |
| $d$       | damping factor which can be set between 0 (inclusive) and 1 (exclusive) |
| $Q$       | modularity of a graph                                        |
| $k_i,k_j$ | the sum of the weights of the edges attached to $community_i$ and $community_j$ |
| $m$       | sum of all of the edge weights in the graph                  |
| $c_i,c_j$ | communities of the nodes                                     |

### PageRank

The PageRank algorithm[^11] evaluates the relevance of each node in the network based on the number of incoming relationships and the importance of the associated source nodes. In general, the underlying notion is that a node is only as important as the nodes that link to it. We assume that a node $A$ has node $T_1$ to $T_n$ which point to it. PageRank is introduced as a function that solves the following equation:
$$
PageRank(A) = (1-d)+d\sum_{i=1}^n \frac{PageRank(T_i)}{C(T_i)}
$$
where $C(A)$ is the number of links going out of node *A*. This equation is used to update a candidate solution iteratively and arrive at an approximate solution. By calculating the PageRank of each node, the centrality of each Part can be defined and represented.

### Louvain Method

The Louvain method[^12] is a community detection method suitable for huge networks. It maximizes a modularity score for each community, where modularity measures the quality of node assignment. This entails determining how much more densely connected nodes within a community are in comparison to how connected they would be in a random network.

In Louvain method, modularity $Q$ of a graph is defined as:
$$
Q = \frac{1}{2m}\sum_{i,j}[A_{i,j}-\frac{k_ik_j}{2m}]\delta(c_i,c_j)
$$
where $A_{i,j}$ is the edge weight between $community_i$ and $community_j$ and $\delta(x,y)$ is Kronecker delta function ($\delta(x,y)=1$ if $x=y$ else $0$).

Louvain algorithm needs to be repeated for two phases to greedily maximize modularity. Phase 1 will put each node in a graph into a distinct community and optimize modularity by allowing only local changes to node-communities memberships. Phase 2 will aggregate communities into super-nodes to build a new network. The new network of super-nodes will then run Phase 1. Phase 1 and Phase 2 will be repeated until no movement yields a gain on the sum of modularity of all communities.

### Implementation

We used a [web crawler](https://gitlab.igem.org/2022/software-tools/fudan/-/blob/main/WebCrawler/software_ver0.4.py) to obtain Parts in 2022 iGEM Registery of Standard Biological Parts. We used Neo4j as the graph database for PartHub 2, and Flask to develop RESTful APIs for PartHub 2. PageRank and Louvain method was performed with [Neo4j Graph Data Science (GDS) library](https://neo4j.com/docs/graph-data-science/current/). PartHub 2 also has docker images available for installation. Like RAP Builder, PartHub 2 supports exporting GeneBank format sequence files via [Biopython](https://biopython.org/).

## DBTL cycles of RAP

RAP is strongly related to the DBTL cycle on two levels, including the fact that RAP may aid users throughout the DBTL cycle and that the development of RAP follows the DBTL cycle.

RAP can provide support throughout the DBTL cycle for users. During the Design phase of the DBTL cycle, the user can utilize PartHub to create a Part network in order to find the proper Part and its sequence. Then users can obtain the kcat of the corresponding enzyme and calculate the optimal enzyme concentration through KineticHub. The user may use RAP Builder for the Build phase to quantitatively produce the synthetic RBS or stem loop while constructing the sequence of pRAP system. Users can determine whether the pRAP system is successfully expressed by measuring its expression and comparing it to the annotation provided by RAP Builder during the Test phase. In Learn phase users can determine the optimal induction intensity of promoters and optimize CDS design by combining experimental data with PartHub's Part Network. In the Learn phase, users may combine experimental data with PartHub's Part Network to discover the optimal induction intensity of promoters and optimize CDS design.

Meanwhile, RAP's development has gone through DBTL cycles. RAP strictly follows [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) and [Semantic Versioning 2.0.0](https://semver.org/). Changelogs capture the changes made in each commit during the development of RAP, and the tags released in GitLab show how RAP improved during the DBTL cycle. It is worth noting that RAP receives feedback from both internal (Fudan iGEM 2023) and external ([SCUT-China iGEM 2023](https://2023.igem.wiki/scut-china/) & [Nanjing-China iGEM 2023](https://2023.igem.wiki/nanjing-china/)) users during DBTL cycles. For more information on DBTL cycles of RAP, please visit our [Engineering](/engineering) page.

## References

[^1]: Kim, K.-J., Kim, H.-E., Lee, K.-H., Han, W., Yi, M.-J., Jeong, J., & Oh, B.-H. (2004). Two-promoter vector is highly efficient for overproduction of protein complexes. *Protein Science: A Publication of the Protein Society*, *13*(6), 1698–1703. https://doi.org/10.1110/ps.04644504
[^2]: Liu, Y., Wu, Z., Wu, D., Gao, N., & Lin, J. (2023). Reconstitution of Multi-Protein Complexes through Ribozyme-Assisted Polycistronic Co-Expression. *ACS Synthetic Biology*, *12*(1), 136–143. https://doi.org/10.1021/acssynbio.2c00416
[^3]: Newbury, S. F., Smith, N. H., & Higgins, C. F. (1987). Differential mRNA stability controls relative gene expression within a polycistronic operon. *Cell*, *51*(6), 1131–1143. https://doi.org/10.1016/0092-8674(87)90599-x
[^4]: Sokolenko, S., George, S., Wagner, A., Tuladhar, A., Andrich, J. M. S., & Aucoin, M. G. (2012). Co-expression vs. co-infection using baculovirus expression vectors in insect cell culture: Benefits and drawbacks. *Biotechnology Advances*, *30*(3), 766–781. https://doi.org/10.1016/j.biotechadv.2012.01.009
[^5]: Chang, A., Jeske, L., Ulbrich, S., Hofmann, J., Koblitz, J., Schomburg, I., Neumann-Schaal, M., Jahn, D., & Schomburg, D. (2021). BRENDA, the ELIXIR core data resource in 2021: New developments and updates. *Nucleic Acids Research*, *49*(D1), D498–D508. https://doi.org/10.1093/nar/gkaa1025
[^6]: Estévez, S. R. (2022). *Robaina/BRENDApyrser: Zenodo* [Computer software]. Zenodo. https://doi.org/10.5281/zenodo.7026555
[^7]: Balakrishnan, R., Mori, M., Segota, I., Zhang, Z., Aebersold, R., Ludwig, C., & Hwa, T. (2022). Principles of gene regulation quantitatively connect DNA to RNA and proteins in bacteria. *Science (New York, N.Y.)*, *378*(6624), eabk2066. https://doi.org/10.1126/science.abk2066
[^8]: Salis, H. M., Mirsky, E. A., & Voigt, C. A. (2009). Automated design of synthetic ribosome binding sites to control protein expression. *Nature Biotechnology*, *27*(10), Article 10. https://doi.org/10.1038/nbt.1568
[^9]: Lorenz, R., Bernhart, S. H., Höner zu Siederdissen, C., Tafer, H., Flamm, C., Stadler, P. F., & Hofacker, I. L. (2011). ViennaRNA Package 2.0. *Algorithms for Molecular Biology*, *6*(1), 26. https://doi.org/10.1186/1748-7188-6-26
[^10]: Salis, H. (2023). *Hsalis/Ribosome-Binding-Site-Calculator-v1.0* [Python]. https://github.com/hsalis/Ribosome-Binding-Site-Calculator-v1.0 (Original work published 2009)
[^11]: Brin, S., & Page, L. (1998). The anatomy of a large-scale hypertextual Web search engine. *Computer Networks and ISDN Systems*, *30*(1), 107–117. https://doi.org/10.1016/S0169-7552(98)00110-X
[^12]: Blondel, V. D., Guillaume, J.-L., Lambiotte, R., & Lefebvre, E. (2008). Fast unfolding of communities in large networks. *Journal of Statistical Mechanics: Theory and Experiment*, *2008*(10), P10008. https://doi.org/10.1088/1742-5468/2008/10/P10008

